"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/analytics/page",{

/***/ "(app-pages-browser)/./lib/analytics.ts":
/*!**************************!*\
  !*** ./lib/analytics.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnalyticsData: function() { return /* binding */ getAnalyticsData; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase/client */ \"(app-pages-browser)/./lib/supabase/client.ts\");\n\nasync function getAnalyticsData() {\n    const supabase = (0,_lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n    try {\n        // Get popular items with their menu details\n        const { data: orders, error: ordersError } = await supabase.from(\"orders\").select(\"\\n        id,\\n        quantity,\\n        created_at,\\n        menu_item:menu_item_id (\\n          name,\\n          price\\n        )\\n      \").order(\"created_at\", {\n            ascending: false\n        }).limit(100);\n        if (ordersError) throw ordersError;\n        // Process popular items data\n        const itemStats = (orders || []).reduce((acc, order)=>{\n            if (!order.menu_item) return acc;\n            const itemName = order.menu_item.name;\n            const price = order.menu_item.price;\n            const quantity = order.quantity;\n            if (!acc[itemName]) {\n                acc[itemName] = {\n                    count: 0,\n                    revenue: 0\n                };\n            }\n            acc[itemName].count += quantity;\n            acc[itemName].revenue += price * quantity;\n            return acc;\n        }, {});\n        const processedPopularItems = Object.entries(itemStats).map((param)=>{\n            let [name, { count, revenue }] = param;\n            return {\n                name,\n                orderCount: count,\n                revenue\n            };\n        }).sort((a, b)=>b.orderCount - a.orderCount).slice(0, 10);\n        // Get order patterns (last 30 days)\n        const thirtyDaysAgo = new Date();\n        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n        const { data: recentOrders, error: recentOrdersError } = await supabase.from(\"orders\").select(\"\\n        id,\\n        quantity,\\n        created_at,\\n        menu_item:menu_item_id (\\n          price\\n        )\\n      \").gte(\"created_at\", thirtyDaysAgo.toISOString()).order(\"created_at\", {\n            ascending: true\n        });\n        if (recentOrdersError) throw recentOrdersError;\n        // Process order patterns data\n        const dailyOrders = (recentOrders || []).reduce((acc, order)=>{\n            if (!order.menu_item) return acc;\n            const date = new Date(order.created_at).toISOString().split(\"T\")[0];\n            if (!acc[date]) {\n                acc[date] = {\n                    count: 0,\n                    revenue: 0\n                };\n            }\n            acc[date].count += order.quantity;\n            acc[date].revenue += order.menu_item.price * order.quantity;\n            return acc;\n        }, {});\n        const processedOrderPatterns = Object.entries(dailyOrders).map((param)=>{\n            let [date, { count, revenue }] = param;\n            return {\n                date,\n                orderCount: count,\n                revenue\n            };\n        }).sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n        // Get customer growth (last 30 days)\n        const { data: customers, error: customersError } = await supabase.from(\"customers\").select(\"created_at\").gte(\"created_at\", thirtyDaysAgo.toISOString()).order(\"created_at\", {\n            ascending: true\n        });\n        if (customersError) throw customersError;\n        // Process customer growth data\n        const dailyCustomers = (customers || []).reduce((acc, customer)=>{\n            const date = new Date(customer.created_at).toISOString().split(\"T\")[0];\n            if (!acc[date]) {\n                acc[date] = {\n                    new: 0\n                };\n            }\n            acc[date].new += 1;\n            return acc;\n        }, {});\n        let totalCustomers = 0;\n        const processedCustomerGrowth = Object.entries(dailyCustomers).map((param)=>{\n            let [date, { new: newCustomers }] = param;\n            totalCustomers += newCustomers;\n            return {\n                date,\n                newCustomers,\n                totalCustomers\n            };\n        }).sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n        // Return empty data if no records found\n        if (processedPopularItems.length === 0 && processedOrderPatterns.length === 0 && processedCustomerGrowth.length === 0) {\n            return {\n                popularItems: [],\n                orderPatterns: [],\n                customerGrowth: []\n            };\n        }\n        return {\n            popularItems: processedPopularItems,\n            orderPatterns: processedOrderPatterns,\n            customerGrowth: processedCustomerGrowth\n        };\n    } catch (error) {\n        console.error(\"Error fetching analytics data:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxDQUFDLENBQUNDLEdBQUdDLElBQU0sSUFBSUcsS0FBS0osRUFBRVksSUFBSSxFQUFFSSxPQUFPLEtBQUssSUFBSVosS0FBS0gsRUFBRVcsSUFBSSxFQUFFSSxPQUFPO1FBRXZFLHdDQUF3QztRQUN4QyxJQUFJdEIsc0JBQXNCK0IsTUFBTSxLQUFLLEtBQUtWLHVCQUF1QlUsTUFBTSxLQUFLLEtBQUtGLHdCQUF3QkUsTUFBTSxLQUFLLEdBQUc7WUFDckgsT0FBTztnQkFDTEMsY0FBYyxFQUFFO2dCQUNoQkMsZUFBZSxFQUFFO2dCQUNqQkMsZ0JBQWdCLEVBQUU7WUFDcEI7UUFDRjtRQUVBLE9BQU87WUFDTEYsY0FBY2hDO1lBQ2RpQyxlQUFlWjtZQUNmYSxnQkFBZ0JMO1FBQ2xCO0lBQ0YsRUFBRSxPQUFPOUMsT0FBTztRQUNkb0QsUUFBUXBELEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2hELE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYW5hbHl0aWNzLnRzP2IzNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2UvY2xpZW50J1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tICdAL3R5cGVzL3N1cGFiYXNlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5dGljc0RhdGEge1xuICBwb3B1bGFySXRlbXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcmRlckNvdW50OiBudW1iZXJcbiAgICByZXZlbnVlOiBudW1iZXJcbiAgfVtdXG4gIG9yZGVyUGF0dGVybnM6IHtcbiAgICBkYXRlOiBzdHJpbmdcbiAgICBvcmRlckNvdW50OiBudW1iZXJcbiAgICByZXZlbnVlOiBudW1iZXJcbiAgfVtdXG4gIGN1c3RvbWVyR3Jvd3RoOiB7XG4gICAgZGF0ZTogc3RyaW5nXG4gICAgbmV3Q3VzdG9tZXJzOiBudW1iZXJcbiAgICB0b3RhbEN1c3RvbWVyczogbnVtYmVyXG4gIH1bXVxufVxuXG5pbnRlcmZhY2UgT3JkZXJEYXRhIHtcbiAgaWQ6IHN0cmluZ1xuICBxdWFudGl0eTogbnVtYmVyXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICBtZW51X2l0ZW06IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBwcmljZTogbnVtYmVyXG4gIH0gfCBudWxsXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbmFseXRpY3NEYXRhKCk6IFByb21pc2U8QW5hbHl0aWNzRGF0YT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudCgpXG5cbiAgdHJ5IHtcbiAgICAvLyBHZXQgcG9wdWxhciBpdGVtcyB3aXRoIHRoZWlyIG1lbnUgZGV0YWlsc1xuICAgIGNvbnN0IHsgZGF0YTogb3JkZXJzLCBlcnJvcjogb3JkZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICBpZCxcbiAgICAgICAgcXVhbnRpdHksXG4gICAgICAgIGNyZWF0ZWRfYXQsXG4gICAgICAgIG1lbnVfaXRlbTptZW51X2l0ZW1faWQgKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcHJpY2VcbiAgICAgICAgKVxuICAgICAgYClcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgLmxpbWl0KDEwMClcblxuICAgIGlmIChvcmRlcnNFcnJvcikgdGhyb3cgb3JkZXJzRXJyb3JcblxuICAgIC8vIFByb2Nlc3MgcG9wdWxhciBpdGVtcyBkYXRhXG4gICAgY29uc3QgaXRlbVN0YXRzID0gKG9yZGVycyB8fCBbXSkucmVkdWNlPFJlY29yZDxzdHJpbmcsIHsgY291bnQ6IG51bWJlcjsgcmV2ZW51ZTogbnVtYmVyIH0+PigoYWNjLCBvcmRlcjogT3JkZXJEYXRhKSA9PiB7XG4gICAgICBpZiAoIW9yZGVyLm1lbnVfaXRlbSkgcmV0dXJuIGFjY1xuXG4gICAgICBjb25zdCBpdGVtTmFtZSA9IG9yZGVyLm1lbnVfaXRlbS5uYW1lXG4gICAgICBjb25zdCBwcmljZSA9IG9yZGVyLm1lbnVfaXRlbS5wcmljZVxuICAgICAgY29uc3QgcXVhbnRpdHkgPSBvcmRlci5xdWFudGl0eVxuXG4gICAgICBpZiAoIWFjY1tpdGVtTmFtZV0pIHtcbiAgICAgICAgYWNjW2l0ZW1OYW1lXSA9IHsgY291bnQ6IDAsIHJldmVudWU6IDAgfVxuICAgICAgfVxuXG4gICAgICBhY2NbaXRlbU5hbWVdLmNvdW50ICs9IHF1YW50aXR5XG4gICAgICBhY2NbaXRlbU5hbWVdLnJldmVudWUgKz0gcHJpY2UgKiBxdWFudGl0eVxuXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwge30pXG5cbiAgICBjb25zdCBwcm9jZXNzZWRQb3B1bGFySXRlbXMgPSBPYmplY3QuZW50cmllcyhpdGVtU3RhdHMpXG4gICAgICAubWFwKChbbmFtZSwgeyBjb3VudCwgcmV2ZW51ZSB9XSkgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgb3JkZXJDb3VudDogY291bnQsXG4gICAgICAgIHJldmVudWVcbiAgICAgIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIub3JkZXJDb3VudCAtIGEub3JkZXJDb3VudClcbiAgICAgIC5zbGljZSgwLCAxMClcblxuICAgIC8vIEdldCBvcmRlciBwYXR0ZXJucyAobGFzdCAzMCBkYXlzKVxuICAgIGNvbnN0IHRoaXJ0eURheXNBZ28gPSBuZXcgRGF0ZSgpXG4gICAgdGhpcnR5RGF5c0Fnby5zZXREYXRlKHRoaXJ0eURheXNBZ28uZ2V0RGF0ZSgpIC0gMzApXG5cbiAgICBjb25zdCB7IGRhdGE6IHJlY2VudE9yZGVycywgZXJyb3I6IHJlY2VudE9yZGVyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ29yZGVycycpXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgaWQsXG4gICAgICAgIHF1YW50aXR5LFxuICAgICAgICBjcmVhdGVkX2F0LFxuICAgICAgICBtZW51X2l0ZW06bWVudV9pdGVtX2lkIChcbiAgICAgICAgICBwcmljZVxuICAgICAgICApXG4gICAgICBgKVxuICAgICAgLmd0ZSgnY3JlYXRlZF9hdCcsIHRoaXJ0eURheXNBZ28udG9JU09TdHJpbmcoKSlcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG5cbiAgICBpZiAocmVjZW50T3JkZXJzRXJyb3IpIHRocm93IHJlY2VudE9yZGVyc0Vycm9yXG5cbiAgICAvLyBQcm9jZXNzIG9yZGVyIHBhdHRlcm5zIGRhdGFcbiAgICBjb25zdCBkYWlseU9yZGVycyA9IChyZWNlbnRPcmRlcnMgfHwgW10pLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCB7IGNvdW50OiBudW1iZXI7IHJldmVudWU6IG51bWJlciB9Pj4oKGFjYywgb3JkZXI6IE9yZGVyRGF0YSkgPT4ge1xuICAgICAgaWYgKCFvcmRlci5tZW51X2l0ZW0pIHJldHVybiBhY2NcblxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKG9yZGVyLmNyZWF0ZWRfYXQpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxuICAgICAgaWYgKCFhY2NbZGF0ZV0pIHtcbiAgICAgICAgYWNjW2RhdGVdID0geyBjb3VudDogMCwgcmV2ZW51ZTogMCB9XG4gICAgICB9XG5cbiAgICAgIGFjY1tkYXRlXS5jb3VudCArPSBvcmRlci5xdWFudGl0eVxuICAgICAgYWNjW2RhdGVdLnJldmVudWUgKz0gb3JkZXIubWVudV9pdGVtLnByaWNlICogb3JkZXIucXVhbnRpdHlcblxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9KVxuXG4gICAgY29uc3QgcHJvY2Vzc2VkT3JkZXJQYXR0ZXJucyA9IE9iamVjdC5lbnRyaWVzKGRhaWx5T3JkZXJzKVxuICAgICAgLm1hcCgoW2RhdGUsIHsgY291bnQsIHJldmVudWUgfV0pID0+ICh7XG4gICAgICAgIGRhdGUsXG4gICAgICAgIG9yZGVyQ291bnQ6IGNvdW50LFxuICAgICAgICByZXZlbnVlXG4gICAgICB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShhLmRhdGUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGIuZGF0ZSkuZ2V0VGltZSgpKVxuXG4gICAgLy8gR2V0IGN1c3RvbWVyIGdyb3d0aCAobGFzdCAzMCBkYXlzKVxuICAgIGNvbnN0IHsgZGF0YTogY3VzdG9tZXJzLCBlcnJvcjogY3VzdG9tZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY3VzdG9tZXJzJylcbiAgICAgIC5zZWxlY3QoJ2NyZWF0ZWRfYXQnKVxuICAgICAgLmd0ZSgnY3JlYXRlZF9hdCcsIHRoaXJ0eURheXNBZ28udG9JU09TdHJpbmcoKSlcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG5cbiAgICBpZiAoY3VzdG9tZXJzRXJyb3IpIHRocm93IGN1c3RvbWVyc0Vycm9yXG5cbiAgICAvLyBQcm9jZXNzIGN1c3RvbWVyIGdyb3d0aCBkYXRhXG4gICAgY29uc3QgZGFpbHlDdXN0b21lcnMgPSAoY3VzdG9tZXJzIHx8IFtdKS5yZWR1Y2U8UmVjb3JkPHN0cmluZywgeyBuZXc6IG51bWJlciB9Pj4oKGFjYywgY3VzdG9tZXIpID0+IHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShjdXN0b21lci5jcmVhdGVkX2F0KS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICAgIGlmICghYWNjW2RhdGVdKSB7XG4gICAgICAgIGFjY1tkYXRlXSA9IHsgbmV3OiAwIH1cbiAgICAgIH1cblxuICAgICAgYWNjW2RhdGVdLm5ldyArPSAxXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSwge30pXG5cbiAgICBsZXQgdG90YWxDdXN0b21lcnMgPSAwXG4gICAgY29uc3QgcHJvY2Vzc2VkQ3VzdG9tZXJHcm93dGggPSBPYmplY3QuZW50cmllcyhkYWlseUN1c3RvbWVycylcbiAgICAgIC5tYXAoKFtkYXRlLCB7IG5ldzogbmV3Q3VzdG9tZXJzIH1dKSA9PiB7XG4gICAgICAgIHRvdGFsQ3VzdG9tZXJzICs9IG5ld0N1c3RvbWVyc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgbmV3Q3VzdG9tZXJzLFxuICAgICAgICAgIHRvdGFsQ3VzdG9tZXJzXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLmRhdGUpLmdldFRpbWUoKSlcblxuICAgIC8vIFJldHVybiBlbXB0eSBkYXRhIGlmIG5vIHJlY29yZHMgZm91bmRcbiAgICBpZiAocHJvY2Vzc2VkUG9wdWxhckl0ZW1zLmxlbmd0aCA9PT0gMCAmJiBwcm9jZXNzZWRPcmRlclBhdHRlcm5zLmxlbmd0aCA9PT0gMCAmJiBwcm9jZXNzZWRDdXN0b21lckdyb3d0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvcHVsYXJJdGVtczogW10sXG4gICAgICAgIG9yZGVyUGF0dGVybnM6IFtdLFxuICAgICAgICBjdXN0b21lckdyb3d0aDogW11cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcG9wdWxhckl0ZW1zOiBwcm9jZXNzZWRQb3B1bGFySXRlbXMsXG4gICAgICBvcmRlclBhdHRlcm5zOiBwcm9jZXNzZWRPcmRlclBhdHRlcm5zLFxuICAgICAgY3VzdG9tZXJHcm93dGg6IHByb2Nlc3NlZEN1c3RvbWVyR3Jvd3RoXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFuYWx5dGljcyBkYXRhOicsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn0gIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsImdldEFuYWx5dGljc0RhdGEiLCJzdXBhYmFzZSIsImRhdGEiLCJvcmRlcnMiLCJlcnJvciIsIm9yZGVyc0Vycm9yIiwiZnJvbSIsInNlbGVjdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibGltaXQiLCJpdGVtU3RhdHMiLCJyZWR1Y2UiLCJhY2MiLCJtZW51X2l0ZW0iLCJpdGVtTmFtZSIsIm5hbWUiLCJwcmljZSIsInF1YW50aXR5IiwiY291bnQiLCJyZXZlbnVlIiwicHJvY2Vzc2VkUG9wdWxhckl0ZW1zIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsIm9yZGVyQ291bnQiLCJzb3J0IiwiYSIsImIiLCJzbGljZSIsInRoaXJ0eURheXNBZ28iLCJEYXRlIiwic2V0RGF0ZSIsImdldERhdGUiLCJyZWNlbnRPcmRlcnMiLCJyZWNlbnRPcmRlcnNFcnJvciIsImd0ZSIsInRvSVNPU3RyaW5nIiwiZGFpbHlPcmRlcnMiLCJkYXRlIiwiY3JlYXRlZF9hdCIsInNwbGl0IiwicHJvY2Vzc2VkT3JkZXJQYXR0ZXJucyIsImdldFRpbWUiLCJjdXN0b21lcnMiLCJjdXN0b21lcnNFcnJvciIsImRhaWx5Q3VzdG9tZXJzIiwiY3VzdG9tZXIiLCJuZXciLCJ0b3RhbEN1c3RvbWVycyIsInByb2Nlc3NlZEN1c3RvbWVyR3Jvd3RoIiwibmV3Q3VzdG9tZXJzIiwibGVuZ3RoIiwicG9wdWxhckl0ZW1zIiwib3JkZXJQYXR0ZXJucyIsImN1c3RvbWVyR3Jvd3RoIiwiY29uc29sZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/analytics.ts\n"));

/***/ })

});