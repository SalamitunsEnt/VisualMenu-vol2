"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/analytics/page",{

/***/ "(app-pages-browser)/./lib/analytics.ts":
/*!**************************!*\
  !*** ./lib/analytics.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnalyticsData: function() { return /* binding */ getAnalyticsData; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase/client */ \"(app-pages-browser)/./lib/supabase/client.ts\");\n\nasync function getAnalyticsData() {\n    const supabase = (0,_lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n    try {\n        // Get popular items\n        const { data: popularItems, error: popularItemsError } = await supabase.from(\"orders\").select(\"\\n        id,\\n        quantity,\\n        menu_item:menu_item_id (\\n          name,\\n          price\\n        )\\n      \").order(\"created_at\", {\n            ascending: false\n        }).limit(100);\n        if (popularItemsError) throw popularItemsError;\n        // Get daily order patterns\n        const { data: orderPatterns, error: orderPatternsError } = await supabase.rpc(\"get_daily_order_patterns\", {\n            days_ago: 30\n        });\n        if (orderPatternsError) throw orderPatternsError;\n        // Get customer growth\n        const { data: customerGrowth, error: customerGrowthError } = await supabase.from(\"customers\").select(\"created_at\").gte(\"created_at\", new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()).order(\"created_at\", {\n            ascending: true\n        });\n        if (customerGrowthError) throw customerGrowthError;\n        // Get peak hours analysis\n        const { data: peakHours, error: peakHoursError } = await supabase.rpc(\"get_peak_hours\");\n        if (peakHoursError) throw peakHoursError;\n        // Get category performance\n        const { data: categoryPerformance, error: categoryError } = await supabase.rpc(\"get_category_performance\");\n        if (categoryError) throw categoryError;\n        // Process the data\n        const processedPopularItems = processPopularItems(popularItems || []);\n        const processedOrderPatterns = processOrderPatterns(orderPatterns || []);\n        const processedCustomerGrowth = processCustomerGrowth(customerGrowth || []);\n        const processedPeakHours = processPeakHours(peakHours || []);\n        const processedCategories = processCategories(categoryPerformance || []);\n        return {\n            popularItems: processedPopularItems,\n            orderPatterns: processedOrderPatterns,\n            customerGrowth: processedCustomerGrowth,\n            peakHours: processedPeakHours,\n            categoryPerformance: processedCategories\n        };\n    } catch (error) {\n        console.error(\"Error fetching analytics data:\", error);\n        throw error;\n    }\n}\nfunction processPopularItems(items) {\n    const itemStats = items.reduce((acc, order)=>{\n        if (!order.menu_item) return acc;\n        const itemName = order.menu_item.name;\n        const price = order.menu_item.price;\n        const quantity = order.quantity;\n        if (!acc[itemName]) {\n            acc[itemName] = {\n                count: 0,\n                revenue: 0\n            };\n        }\n        acc[itemName].count += quantity;\n        acc[itemName].revenue += price * quantity;\n        return acc;\n    }, {});\n    return Object.entries(itemStats).map((param)=>{\n        let [name, { count, revenue }] = param;\n        return {\n            name,\n            orderCount: count,\n            revenue\n        };\n    }).sort((a, b)=>b.orderCount - a.orderCount).slice(0, 10);\n}\nfunction processOrderPatterns(patterns) {\n    return patterns.map((pattern)=>({\n            date: pattern.date,\n            orderCount: pattern.total_orders,\n            revenue: pattern.daily_revenue,\n            itemsSold: pattern.items_sold,\n            averageOrderValue: pattern.average_order_value\n        }));\n}\nfunction processCustomerGrowth(customers) {\n    const dailyCustomers = customers.reduce((acc, customer)=>{\n        const date = new Date(customer.created_at).toISOString().split(\"T\")[0];\n        if (!acc[date]) {\n            acc[date] = {\n                new: 0\n            };\n        }\n        acc[date].new += 1;\n        return acc;\n    }, {});\n    let totalCustomers = 0;\n    return Object.entries(dailyCustomers).map((param)=>{\n        let [date, { new: newCustomers }] = param;\n        totalCustomers += newCustomers;\n        return {\n            date,\n            newCustomers,\n            totalCustomers\n        };\n    }).sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n}\nfunction processPeakHours(hours) {\n    return hours.map((hour)=>({\n            hour: hour.hour_of_day,\n            orderCount: hour.total_orders,\n            revenue: hour.revenue,\n            itemsSold: hour.items_sold\n        }));\n}\nfunction processCategories(categories) {\n    return categories.map((category)=>({\n            category: category.category,\n            orderCount: category.total_orders,\n            revenue: category.revenue,\n            itemsSold: category.items_sold\n        }));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUdDLElBQU0sSUFBSW5DLEtBQUtrQyxFQUFFSyxJQUFJLEVBQUVlLE9BQU8sS0FBSyxJQUFJdEQsS0FBS21DLEVBQUVJLElBQUksRUFBRWUsT0FBTztBQUN6RTtBQUVBLFNBQVN4QyxpQkFBaUJ5QyxLQUFZO0lBQ3BDLE9BQU9BLE1BQU14QixHQUFHLENBQUN5QixDQUFBQSxPQUFTO1lBQ3hCQSxNQUFNQSxLQUFLQyxXQUFXO1lBQ3RCekIsWUFBWXdCLEtBQUtoQixZQUFZO1lBQzdCWixTQUFTNEIsS0FBSzVCLE9BQU87WUFDckJjLFdBQVdjLEtBQUtiLFVBQVU7UUFDNUI7QUFDRjtBQUVBLFNBQVMzQixrQkFBa0IwQyxVQUFpQjtJQUMxQyxPQUFPQSxXQUFXM0IsR0FBRyxDQUFDNEIsQ0FBQUEsV0FBYTtZQUNqQ0EsVUFBVUEsU0FBU0EsUUFBUTtZQUMzQjNCLFlBQVkyQixTQUFTbkIsWUFBWTtZQUNqQ1osU0FBUytCLFNBQVMvQixPQUFPO1lBQ3pCYyxXQUFXaUIsU0FBU2hCLFVBQVU7UUFDaEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYW5hbHl0aWNzLnRzP2IzNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2UvY2xpZW50J1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tICdAL3R5cGVzL3N1cGFiYXNlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5dGljc0RhdGEge1xuICBwb3B1bGFySXRlbXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcmRlckNvdW50OiBudW1iZXJcbiAgICByZXZlbnVlOiBudW1iZXJcbiAgfVtdXG4gIG9yZGVyUGF0dGVybnM6IHtcbiAgICBkYXRlOiBzdHJpbmdcbiAgICBvcmRlckNvdW50OiBudW1iZXJcbiAgICByZXZlbnVlOiBudW1iZXJcbiAgICBpdGVtc1NvbGQ6IG51bWJlclxuICAgIGF2ZXJhZ2VPcmRlclZhbHVlOiBudW1iZXJcbiAgfVtdXG4gIGN1c3RvbWVyR3Jvd3RoOiB7XG4gICAgZGF0ZTogc3RyaW5nXG4gICAgbmV3Q3VzdG9tZXJzOiBudW1iZXJcbiAgICB0b3RhbEN1c3RvbWVyczogbnVtYmVyXG4gIH1bXVxuICBwZWFrSG91cnM6IHtcbiAgICBob3VyOiBudW1iZXJcbiAgICBvcmRlckNvdW50OiBudW1iZXJcbiAgICByZXZlbnVlOiBudW1iZXJcbiAgICBpdGVtc1NvbGQ6IG51bWJlclxuICB9W11cbiAgY2F0ZWdvcnlQZXJmb3JtYW5jZToge1xuICAgIGNhdGVnb3J5OiBzdHJpbmdcbiAgICBvcmRlckNvdW50OiBudW1iZXJcbiAgICByZXZlbnVlOiBudW1iZXJcbiAgICBpdGVtc1NvbGQ6IG51bWJlclxuICB9W11cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFuYWx5dGljc0RhdGEoKTogUHJvbWlzZTxBbmFseXRpY3NEYXRhPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KClcblxuICB0cnkge1xuICAgIC8vIEdldCBwb3B1bGFyIGl0ZW1zXG4gICAgY29uc3QgeyBkYXRhOiBwb3B1bGFySXRlbXMsIGVycm9yOiBwb3B1bGFySXRlbXNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdvcmRlcnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgIGlkLFxuICAgICAgICBxdWFudGl0eSxcbiAgICAgICAgbWVudV9pdGVtOm1lbnVfaXRlbV9pZCAoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBwcmljZVxuICAgICAgICApXG4gICAgICBgKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAubGltaXQoMTAwKVxuXG4gICAgaWYgKHBvcHVsYXJJdGVtc0Vycm9yKSB0aHJvdyBwb3B1bGFySXRlbXNFcnJvclxuXG4gICAgLy8gR2V0IGRhaWx5IG9yZGVyIHBhdHRlcm5zXG4gICAgY29uc3QgeyBkYXRhOiBvcmRlclBhdHRlcm5zLCBlcnJvcjogb3JkZXJQYXR0ZXJuc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLnJwYygnZ2V0X2RhaWx5X29yZGVyX3BhdHRlcm5zJywge1xuICAgICAgICBkYXlzX2FnbzogMzBcbiAgICAgIH0pXG5cbiAgICBpZiAob3JkZXJQYXR0ZXJuc0Vycm9yKSB0aHJvdyBvcmRlclBhdHRlcm5zRXJyb3JcblxuICAgIC8vIEdldCBjdXN0b21lciBncm93dGhcbiAgICBjb25zdCB7IGRhdGE6IGN1c3RvbWVyR3Jvd3RoLCBlcnJvcjogY3VzdG9tZXJHcm93dGhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdjdXN0b21lcnMnKVxuICAgICAgLnNlbGVjdCgnY3JlYXRlZF9hdCcpXG4gICAgICAuZ3RlKCdjcmVhdGVkX2F0JywgbmV3IERhdGUoRGF0ZS5ub3coKSAtIDMwICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSlcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiB0cnVlIH0pXG5cbiAgICBpZiAoY3VzdG9tZXJHcm93dGhFcnJvcikgdGhyb3cgY3VzdG9tZXJHcm93dGhFcnJvclxuXG4gICAgLy8gR2V0IHBlYWsgaG91cnMgYW5hbHlzaXNcbiAgICBjb25zdCB7IGRhdGE6IHBlYWtIb3VycywgZXJyb3I6IHBlYWtIb3Vyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLnJwYygnZ2V0X3BlYWtfaG91cnMnKVxuXG4gICAgaWYgKHBlYWtIb3Vyc0Vycm9yKSB0aHJvdyBwZWFrSG91cnNFcnJvclxuXG4gICAgLy8gR2V0IGNhdGVnb3J5IHBlcmZvcm1hbmNlXG4gICAgY29uc3QgeyBkYXRhOiBjYXRlZ29yeVBlcmZvcm1hbmNlLCBlcnJvcjogY2F0ZWdvcnlFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5ycGMoJ2dldF9jYXRlZ29yeV9wZXJmb3JtYW5jZScpXG5cbiAgICBpZiAoY2F0ZWdvcnlFcnJvcikgdGhyb3cgY2F0ZWdvcnlFcnJvclxuXG4gICAgLy8gUHJvY2VzcyB0aGUgZGF0YVxuICAgIGNvbnN0IHByb2Nlc3NlZFBvcHVsYXJJdGVtcyA9IHByb2Nlc3NQb3B1bGFySXRlbXMocG9wdWxhckl0ZW1zIHx8IFtdKVxuICAgIGNvbnN0IHByb2Nlc3NlZE9yZGVyUGF0dGVybnMgPSBwcm9jZXNzT3JkZXJQYXR0ZXJucyhvcmRlclBhdHRlcm5zIHx8IFtdKVxuICAgIGNvbnN0IHByb2Nlc3NlZEN1c3RvbWVyR3Jvd3RoID0gcHJvY2Vzc0N1c3RvbWVyR3Jvd3RoKGN1c3RvbWVyR3Jvd3RoIHx8IFtdKVxuICAgIGNvbnN0IHByb2Nlc3NlZFBlYWtIb3VycyA9IHByb2Nlc3NQZWFrSG91cnMocGVha0hvdXJzIHx8IFtdKVxuICAgIGNvbnN0IHByb2Nlc3NlZENhdGVnb3JpZXMgPSBwcm9jZXNzQ2F0ZWdvcmllcyhjYXRlZ29yeVBlcmZvcm1hbmNlIHx8IFtdKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcHVsYXJJdGVtczogcHJvY2Vzc2VkUG9wdWxhckl0ZW1zLFxuICAgICAgb3JkZXJQYXR0ZXJuczogcHJvY2Vzc2VkT3JkZXJQYXR0ZXJucyxcbiAgICAgIGN1c3RvbWVyR3Jvd3RoOiBwcm9jZXNzZWRDdXN0b21lckdyb3d0aCxcbiAgICAgIHBlYWtIb3VyczogcHJvY2Vzc2VkUGVha0hvdXJzLFxuICAgICAgY2F0ZWdvcnlQZXJmb3JtYW5jZTogcHJvY2Vzc2VkQ2F0ZWdvcmllc1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhbmFseXRpY3MgZGF0YTonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQb3B1bGFySXRlbXMoaXRlbXM6IGFueVtdKTogQW5hbHl0aWNzRGF0YVsncG9wdWxhckl0ZW1zJ10ge1xuICBjb25zdCBpdGVtU3RhdHMgPSBpdGVtcy5yZWR1Y2UoKGFjYzogUmVjb3JkPHN0cmluZywgeyBjb3VudDogbnVtYmVyOyByZXZlbnVlOiBudW1iZXIgfT4sIG9yZGVyKSA9PiB7XG4gICAgaWYgKCFvcmRlci5tZW51X2l0ZW0pIHJldHVybiBhY2NcblxuICAgIGNvbnN0IGl0ZW1OYW1lID0gb3JkZXIubWVudV9pdGVtLm5hbWVcbiAgICBjb25zdCBwcmljZSA9IG9yZGVyLm1lbnVfaXRlbS5wcmljZVxuICAgIGNvbnN0IHF1YW50aXR5ID0gb3JkZXIucXVhbnRpdHlcblxuICAgIGlmICghYWNjW2l0ZW1OYW1lXSkge1xuICAgICAgYWNjW2l0ZW1OYW1lXSA9IHsgY291bnQ6IDAsIHJldmVudWU6IDAgfVxuICAgIH1cblxuICAgIGFjY1tpdGVtTmFtZV0uY291bnQgKz0gcXVhbnRpdHlcbiAgICBhY2NbaXRlbU5hbWVdLnJldmVudWUgKz0gcHJpY2UgKiBxdWFudGl0eVxuXG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSlcblxuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoaXRlbVN0YXRzKVxuICAgIC5tYXAoKFtuYW1lLCB7IGNvdW50LCByZXZlbnVlIH1dKSA9PiAoe1xuICAgICAgbmFtZSxcbiAgICAgIG9yZGVyQ291bnQ6IGNvdW50LFxuICAgICAgcmV2ZW51ZVxuICAgIH0pKVxuICAgIC5zb3J0KChhLCBiKSA9PiBiLm9yZGVyQ291bnQgLSBhLm9yZGVyQ291bnQpXG4gICAgLnNsaWNlKDAsIDEwKVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzT3JkZXJQYXR0ZXJucyhwYXR0ZXJuczogYW55W10pOiBBbmFseXRpY3NEYXRhWydvcmRlclBhdHRlcm5zJ10ge1xuICByZXR1cm4gcGF0dGVybnMubWFwKHBhdHRlcm4gPT4gKHtcbiAgICBkYXRlOiBwYXR0ZXJuLmRhdGUsXG4gICAgb3JkZXJDb3VudDogcGF0dGVybi50b3RhbF9vcmRlcnMsXG4gICAgcmV2ZW51ZTogcGF0dGVybi5kYWlseV9yZXZlbnVlLFxuICAgIGl0ZW1zU29sZDogcGF0dGVybi5pdGVtc19zb2xkLFxuICAgIGF2ZXJhZ2VPcmRlclZhbHVlOiBwYXR0ZXJuLmF2ZXJhZ2Vfb3JkZXJfdmFsdWVcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDdXN0b21lckdyb3d0aChjdXN0b21lcnM6IGFueVtdKTogQW5hbHl0aWNzRGF0YVsnY3VzdG9tZXJHcm93dGgnXSB7XG4gIGNvbnN0IGRhaWx5Q3VzdG9tZXJzID0gY3VzdG9tZXJzLnJlZHVjZSgoYWNjOiBSZWNvcmQ8c3RyaW5nLCB7IG5ldzogbnVtYmVyIH0+LCBjdXN0b21lcikgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShjdXN0b21lci5jcmVhdGVkX2F0KS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICBpZiAoIWFjY1tkYXRlXSkge1xuICAgICAgYWNjW2RhdGVdID0geyBuZXc6IDAgfVxuICAgIH1cbiAgICBhY2NbZGF0ZV0ubmV3ICs9IDFcbiAgICByZXR1cm4gYWNjXG4gIH0sIHt9KVxuXG4gIGxldCB0b3RhbEN1c3RvbWVycyA9IDBcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGRhaWx5Q3VzdG9tZXJzKVxuICAgIC5tYXAoKFtkYXRlLCB7IG5ldzogbmV3Q3VzdG9tZXJzIH1dKSA9PiB7XG4gICAgICB0b3RhbEN1c3RvbWVycyArPSBuZXdDdXN0b21lcnNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGUsXG4gICAgICAgIG5ld0N1c3RvbWVycyxcbiAgICAgICAgdG90YWxDdXN0b21lcnNcbiAgICAgIH1cbiAgICB9KVxuICAgIC5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShhLmRhdGUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGIuZGF0ZSkuZ2V0VGltZSgpKVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUGVha0hvdXJzKGhvdXJzOiBhbnlbXSk6IEFuYWx5dGljc0RhdGFbJ3BlYWtIb3VycyddIHtcbiAgcmV0dXJuIGhvdXJzLm1hcChob3VyID0+ICh7XG4gICAgaG91cjogaG91ci5ob3VyX29mX2RheSxcbiAgICBvcmRlckNvdW50OiBob3VyLnRvdGFsX29yZGVycyxcbiAgICByZXZlbnVlOiBob3VyLnJldmVudWUsXG4gICAgaXRlbXNTb2xkOiBob3VyLml0ZW1zX3NvbGRcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDYXRlZ29yaWVzKGNhdGVnb3JpZXM6IGFueVtdKTogQW5hbHl0aWNzRGF0YVsnY2F0ZWdvcnlQZXJmb3JtYW5jZSddIHtcbiAgcmV0dXJuIGNhdGVnb3JpZXMubWFwKGNhdGVnb3J5ID0+ICh7XG4gICAgY2F0ZWdvcnk6IGNhdGVnb3J5LmNhdGVnb3J5LFxuICAgIG9yZGVyQ291bnQ6IGNhdGVnb3J5LnRvdGFsX29yZGVycyxcbiAgICByZXZlbnVlOiBjYXRlZ29yeS5yZXZlbnVlLFxuICAgIGl0ZW1zU29sZDogY2F0ZWdvcnkuaXRlbXNfc29sZFxuICB9KSlcbn0gIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsImdldEFuYWx5dGljc0RhdGEiLCJzdXBhYmFzZSIsImRhdGEiLCJwb3B1bGFySXRlbXMiLCJlcnJvciIsInBvcHVsYXJJdGVtc0Vycm9yIiwiZnJvbSIsInNlbGVjdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibGltaXQiLCJvcmRlclBhdHRlcm5zIiwib3JkZXJQYXR0ZXJuc0Vycm9yIiwicnBjIiwiZGF5c19hZ28iLCJjdXN0b21lckdyb3d0aCIsImN1c3RvbWVyR3Jvd3RoRXJyb3IiLCJndGUiLCJEYXRlIiwibm93IiwidG9JU09TdHJpbmciLCJwZWFrSG91cnMiLCJwZWFrSG91cnNFcnJvciIsImNhdGVnb3J5UGVyZm9ybWFuY2UiLCJjYXRlZ29yeUVycm9yIiwicHJvY2Vzc2VkUG9wdWxhckl0ZW1zIiwicHJvY2Vzc1BvcHVsYXJJdGVtcyIsInByb2Nlc3NlZE9yZGVyUGF0dGVybnMiLCJwcm9jZXNzT3JkZXJQYXR0ZXJucyIsInByb2Nlc3NlZEN1c3RvbWVyR3Jvd3RoIiwicHJvY2Vzc0N1c3RvbWVyR3Jvd3RoIiwicHJvY2Vzc2VkUGVha0hvdXJzIiwicHJvY2Vzc1BlYWtIb3VycyIsInByb2Nlc3NlZENhdGVnb3JpZXMiLCJwcm9jZXNzQ2F0ZWdvcmllcyIsImNvbnNvbGUiLCJpdGVtcyIsIml0ZW1TdGF0cyIsInJlZHVjZSIsImFjYyIsIm1lbnVfaXRlbSIsIml0ZW1OYW1lIiwibmFtZSIsInByaWNlIiwicXVhbnRpdHkiLCJjb3VudCIsInJldmVudWUiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwib3JkZXJDb3VudCIsInNvcnQiLCJhIiwiYiIsInNsaWNlIiwicGF0dGVybnMiLCJwYXR0ZXJuIiwiZGF0ZSIsInRvdGFsX29yZGVycyIsImRhaWx5X3JldmVudWUiLCJpdGVtc1NvbGQiLCJpdGVtc19zb2xkIiwiYXZlcmFnZU9yZGVyVmFsdWUiLCJhdmVyYWdlX29yZGVyX3ZhbHVlIiwiY3VzdG9tZXJzIiwiZGFpbHlDdXN0b21lcnMiLCJjdXN0b21lciIsImNyZWF0ZWRfYXQiLCJzcGxpdCIsIm5ldyIsInRvdGFsQ3VzdG9tZXJzIiwibmV3Q3VzdG9tZXJzIiwiZ2V0VGltZSIsImhvdXJzIiwiaG91ciIsImhvdXJfb2ZfZGF5IiwiY2F0ZWdvcmllcyIsImNhdGVnb3J5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/analytics.ts\n"));

/***/ })

});