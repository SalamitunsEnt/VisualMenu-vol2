"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/analytics/page",{

/***/ "(app-pages-browser)/./lib/analytics.ts":
/*!**************************!*\
  !*** ./lib/analytics.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnalyticsData: function() { return /* binding */ getAnalyticsData; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase/client */ \"(app-pages-browser)/./lib/supabase/client.ts\");\n\nasync function getAnalyticsData() {\n    const supabase = (0,_lib_supabase_client__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n    try {\n        // Get popular items with their menu details\n        const { data: orders, error: ordersError } = await supabase.from(\"orders\").select(\"\\n        id,\\n        quantity,\\n        created_at,\\n        menu_item:menu_item_id (\\n          name,\\n          price\\n        )\\n      \").order(\"created_at\", {\n            ascending: false\n        }).limit(100);\n        if (ordersError) throw ordersError;\n        // Process popular items data\n        const itemStats = (orders || []).reduce((acc, order)=>{\n            if (!order.menu_item) return acc;\n            const itemName = order.menu_item.name;\n            const price = order.menu_item.price;\n            const quantity = order.quantity;\n            if (!acc[itemName]) {\n                acc[itemName] = {\n                    count: 0,\n                    revenue: 0\n                };\n            }\n            acc[itemName].count += quantity;\n            acc[itemName].revenue += price * quantity;\n            return acc;\n        }, {});\n        const processedPopularItems = Object.entries(itemStats).map((param)=>{\n            let [name, { count, revenue }] = param;\n            return {\n                name,\n                orderCount: count,\n                revenue\n            };\n        }).sort((a, b)=>b.orderCount - a.orderCount).slice(0, 10);\n        // Get order patterns (last 30 days)\n        const thirtyDaysAgo = new Date();\n        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n        const { data: recentOrders, error: recentOrdersError } = await supabase.from(\"orders\").select(\"\\n        id,\\n        quantity,\\n        created_at,\\n        menu_item:menu_item_id (\\n          price\\n        )\\n      \").gte(\"created_at\", thirtyDaysAgo.toISOString()).order(\"created_at\", {\n            ascending: true\n        });\n        if (recentOrdersError) throw recentOrdersError;\n        // Process order patterns data\n        const dailyOrders = (recentOrders || []).reduce((acc, order)=>{\n            if (!order.menu_item) return acc;\n            const date = new Date(order.created_at).toISOString().split(\"T\")[0];\n            if (!acc[date]) {\n                acc[date] = {\n                    count: 0,\n                    revenue: 0\n                };\n            }\n            acc[date].count += order.quantity;\n            acc[date].revenue += order.menu_item.price * order.quantity;\n            return acc;\n        }, {});\n        const processedOrderPatterns = Object.entries(dailyOrders).map((param)=>{\n            let [date, { count, revenue }] = param;\n            return {\n                date,\n                orderCount: count,\n                revenue\n            };\n        }).sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n        // Get customer growth (last 30 days)\n        const { data: customers, error: customersError } = await supabase.from(\"customers\").select(\"created_at\").gte(\"created_at\", thirtyDaysAgo.toISOString()).order(\"created_at\", {\n            ascending: true\n        });\n        if (customersError) throw customersError;\n        // Process customer growth data\n        const dailyCustomers = (customers || []).reduce((acc, customer)=>{\n            const date = new Date(customer.created_at).toISOString().split(\"T\")[0];\n            if (!acc[date]) {\n                acc[date] = {\n                    new: 0\n                };\n            }\n            acc[date].new += 1;\n            return acc;\n        }, {});\n        let totalCustomers = 0;\n        const processedCustomerGrowth = Object.entries(dailyCustomers).map((param)=>{\n            let [date, { new: newCustomers }] = param;\n            totalCustomers += newCustomers;\n            return {\n                date,\n                newCustomers,\n                totalCustomers\n            };\n        }).sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime());\n        // Return empty data if no records found\n        if (processedPopularItems.length === 0 && processedOrderPatterns.length === 0 && processedCustomerGrowth.length === 0) {\n            return {\n                popularItems: [],\n                orderPatterns: [],\n                customerGrowth: []\n            };\n        }\n        return {\n            popularItems: processedPopularItems,\n            orderPatterns: processedOrderPatterns,\n            customerGrowth: processedCustomerGrowth\n        };\n    } catch (error) {\n        console.error(\"Error fetching analytics data:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxDQUFDLENBQUNDLEdBQUdDLElBQU0sSUFBSUcsS0FBS0osRUFBRVksSUFBSSxFQUFFSSxPQUFPLEtBQUssSUFBSVosS0FBS0gsRUFBRVcsSUFBSSxFQUFFSSxPQUFPO1FBRXZFLHdDQUF3QztRQUN4QyxJQUFJdEIsc0JBQXNCK0IsTUFBTSxLQUFLLEtBQUtWLHVCQUF1QlUsTUFBTSxLQUFLLEtBQUtGLHdCQUF3QkUsTUFBTSxLQUFLLEdBQUc7WUFDckgsT0FBTztnQkFDTEMsY0FBYyxFQUFFO2dCQUNoQkMsZUFBZSxFQUFFO2dCQUNqQkMsZ0JBQWdCLEVBQUU7WUFDcEI7UUFDRjtRQUVBLE9BQU87WUFDTEYsY0FBY2hDO1lBQ2RpQyxlQUFlWjtZQUNmYSxnQkFBZ0JMO1FBQ2xCO0lBQ0YsRUFBRSxPQUFPOUMsT0FBTztRQUNkb0QsUUFBUXBELEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2hELE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYW5hbHl0aWNzLnRzP2IzNjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQC9saWIvc3VwYWJhc2UvY2xpZW50J1xuaW1wb3J0IHsgRGF0YWJhc2UgfSBmcm9tICdAL3R5cGVzL3N1cGFiYXNlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEFuYWx5dGljc0RhdGEge1xuICBwb3B1bGFySXRlbXM6IHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBvcmRlckNvdW50OiBudW1iZXJcbiAgICByZXZlbnVlOiBudW1iZXJcbiAgfVtdXG4gIG9yZGVyUGF0dGVybnM6IHtcbiAgICBkYXRlOiBzdHJpbmdcbiAgICBvcmRlckNvdW50OiBudW1iZXJcbiAgICByZXZlbnVlOiBudW1iZXJcbiAgfVtdXG4gIGN1c3RvbWVyR3Jvd3RoOiB7XG4gICAgZGF0ZTogc3RyaW5nXG4gICAgbmV3Q3VzdG9tZXJzOiBudW1iZXJcbiAgICB0b3RhbEN1c3RvbWVyczogbnVtYmVyXG4gIH1bXVxufVxuXG50eXBlIE9yZGVyID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsnb3JkZXJzJ11bJ1JvdyddXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbmFseXRpY3NEYXRhKCk6IFByb21pc2U8QW5hbHl0aWNzRGF0YT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudCgpXG5cbiAgdHJ5IHtcbiAgICAvLyBHZXQgcG9wdWxhciBpdGVtcyB3aXRoIHRoZWlyIG1lbnUgZGV0YWlsc1xuICAgIGNvbnN0IHsgZGF0YTogb3JkZXJzLCBlcnJvcjogb3JkZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICBpZCxcbiAgICAgICAgcXVhbnRpdHksXG4gICAgICAgIGNyZWF0ZWRfYXQsXG4gICAgICAgIG1lbnVfaXRlbTptZW51X2l0ZW1faWQgKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcHJpY2VcbiAgICAgICAgKVxuICAgICAgYClcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgLmxpbWl0KDEwMClcblxuICAgIGlmIChvcmRlcnNFcnJvcikgdGhyb3cgb3JkZXJzRXJyb3JcblxuICAgIC8vIFByb2Nlc3MgcG9wdWxhciBpdGVtcyBkYXRhXG4gICAgY29uc3QgaXRlbVN0YXRzID0gKG9yZGVycyB8fCBbXSkucmVkdWNlPFJlY29yZDxzdHJpbmcsIHsgY291bnQ6IG51bWJlcjsgcmV2ZW51ZTogbnVtYmVyIH0+PigoYWNjLCBvcmRlcjogT3JkZXIpID0+IHtcbiAgICAgIGlmICghb3JkZXIubWVudV9pdGVtKSByZXR1cm4gYWNjXG5cbiAgICAgIGNvbnN0IGl0ZW1OYW1lID0gb3JkZXIubWVudV9pdGVtLm5hbWVcbiAgICAgIGNvbnN0IHByaWNlID0gb3JkZXIubWVudV9pdGVtLnByaWNlXG4gICAgICBjb25zdCBxdWFudGl0eSA9IG9yZGVyLnF1YW50aXR5XG5cbiAgICAgIGlmICghYWNjW2l0ZW1OYW1lXSkge1xuICAgICAgICBhY2NbaXRlbU5hbWVdID0geyBjb3VudDogMCwgcmV2ZW51ZTogMCB9XG4gICAgICB9XG5cbiAgICAgIGFjY1tpdGVtTmFtZV0uY291bnQgKz0gcXVhbnRpdHlcbiAgICAgIGFjY1tpdGVtTmFtZV0ucmV2ZW51ZSArPSBwcmljZSAqIHF1YW50aXR5XG5cbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCB7fSlcblxuICAgIGNvbnN0IHByb2Nlc3NlZFBvcHVsYXJJdGVtcyA9IE9iamVjdC5lbnRyaWVzKGl0ZW1TdGF0cylcbiAgICAgIC5tYXAoKFtuYW1lLCB7IGNvdW50LCByZXZlbnVlIH1dKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBvcmRlckNvdW50OiBjb3VudCxcbiAgICAgICAgcmV2ZW51ZVxuICAgICAgfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5vcmRlckNvdW50IC0gYS5vcmRlckNvdW50KVxuICAgICAgLnNsaWNlKDAsIDEwKVxuXG4gICAgLy8gR2V0IG9yZGVyIHBhdHRlcm5zIChsYXN0IDMwIGRheXMpXG4gICAgY29uc3QgdGhpcnR5RGF5c0FnbyA9IG5ldyBEYXRlKClcbiAgICB0aGlydHlEYXlzQWdvLnNldERhdGUodGhpcnR5RGF5c0Fnby5nZXREYXRlKCkgLSAzMClcblxuICAgIGNvbnN0IHsgZGF0YTogcmVjZW50T3JkZXJzLCBlcnJvcjogcmVjZW50T3JkZXJzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnb3JkZXJzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICBpZCxcbiAgICAgICAgcXVhbnRpdHksXG4gICAgICAgIGNyZWF0ZWRfYXQsXG4gICAgICAgIG1lbnVfaXRlbTptZW51X2l0ZW1faWQgKFxuICAgICAgICAgIHByaWNlXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuZ3RlKCdjcmVhdGVkX2F0JywgdGhpcnR5RGF5c0Fnby50b0lTT1N0cmluZygpKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IHRydWUgfSlcblxuICAgIGlmIChyZWNlbnRPcmRlcnNFcnJvcikgdGhyb3cgcmVjZW50T3JkZXJzRXJyb3JcblxuICAgIC8vIFByb2Nlc3Mgb3JkZXIgcGF0dGVybnMgZGF0YVxuICAgIGNvbnN0IGRhaWx5T3JkZXJzID0gKHJlY2VudE9yZGVycyB8fCBbXSkucmVkdWNlPFJlY29yZDxzdHJpbmcsIHsgY291bnQ6IG51bWJlcjsgcmV2ZW51ZTogbnVtYmVyIH0+PigoYWNjLCBvcmRlcjogT3JkZXIpID0+IHtcbiAgICAgIGlmICghb3JkZXIubWVudV9pdGVtKSByZXR1cm4gYWNjXG5cbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShvcmRlci5jcmVhdGVkX2F0KS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICAgIGlmICghYWNjW2RhdGVdKSB7XG4gICAgICAgIGFjY1tkYXRlXSA9IHsgY291bnQ6IDAsIHJldmVudWU6IDAgfVxuICAgICAgfVxuXG4gICAgICBhY2NbZGF0ZV0uY291bnQgKz0gb3JkZXIucXVhbnRpdHlcbiAgICAgIGFjY1tkYXRlXS5yZXZlbnVlICs9IG9yZGVyLm1lbnVfaXRlbS5wcmljZSAqIG9yZGVyLnF1YW50aXR5XG5cbiAgICAgIHJldHVybiBhY2NcbiAgICB9LCB7fSlcblxuICAgIGNvbnN0IHByb2Nlc3NlZE9yZGVyUGF0dGVybnMgPSBPYmplY3QuZW50cmllcyhkYWlseU9yZGVycylcbiAgICAgIC5tYXAoKFtkYXRlLCB7IGNvdW50LCByZXZlbnVlIH1dKSA9PiAoe1xuICAgICAgICBkYXRlLFxuICAgICAgICBvcmRlckNvdW50OiBjb3VudCxcbiAgICAgICAgcmV2ZW51ZVxuICAgICAgfSkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLmRhdGUpLmdldFRpbWUoKSlcblxuICAgIC8vIEdldCBjdXN0b21lciBncm93dGggKGxhc3QgMzAgZGF5cylcbiAgICBjb25zdCB7IGRhdGE6IGN1c3RvbWVycywgZXJyb3I6IGN1c3RvbWVyc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2N1c3RvbWVycycpXG4gICAgICAuc2VsZWN0KCdjcmVhdGVkX2F0JylcbiAgICAgIC5ndGUoJ2NyZWF0ZWRfYXQnLCB0aGlydHlEYXlzQWdvLnRvSVNPU3RyaW5nKCkpXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KVxuXG4gICAgaWYgKGN1c3RvbWVyc0Vycm9yKSB0aHJvdyBjdXN0b21lcnNFcnJvclxuXG4gICAgLy8gUHJvY2VzcyBjdXN0b21lciBncm93dGggZGF0YVxuICAgIGNvbnN0IGRhaWx5Q3VzdG9tZXJzID0gKGN1c3RvbWVycyB8fCBbXSkucmVkdWNlPFJlY29yZDxzdHJpbmcsIHsgbmV3OiBudW1iZXIgfT4+KChhY2MsIGN1c3RvbWVyKSA9PiB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoY3VzdG9tZXIuY3JlYXRlZF9hdCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG4gICAgICBpZiAoIWFjY1tkYXRlXSkge1xuICAgICAgICBhY2NbZGF0ZV0gPSB7IG5ldzogMCB9XG4gICAgICB9XG5cbiAgICAgIGFjY1tkYXRlXS5uZXcgKz0gMVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9KVxuXG4gICAgbGV0IHRvdGFsQ3VzdG9tZXJzID0gMFxuICAgIGNvbnN0IHByb2Nlc3NlZEN1c3RvbWVyR3Jvd3RoID0gT2JqZWN0LmVudHJpZXMoZGFpbHlDdXN0b21lcnMpXG4gICAgICAubWFwKChbZGF0ZSwgeyBuZXc6IG5ld0N1c3RvbWVycyB9XSkgPT4ge1xuICAgICAgICB0b3RhbEN1c3RvbWVycyArPSBuZXdDdXN0b21lcnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRlLFxuICAgICAgICAgIG5ld0N1c3RvbWVycyxcbiAgICAgICAgICB0b3RhbEN1c3RvbWVyc1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnNvcnQoKGEsIGIpID0+IG5ldyBEYXRlKGEuZGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYi5kYXRlKS5nZXRUaW1lKCkpXG5cbiAgICAvLyBSZXR1cm4gZW1wdHkgZGF0YSBpZiBubyByZWNvcmRzIGZvdW5kXG4gICAgaWYgKHByb2Nlc3NlZFBvcHVsYXJJdGVtcy5sZW5ndGggPT09IDAgJiYgcHJvY2Vzc2VkT3JkZXJQYXR0ZXJucy5sZW5ndGggPT09IDAgJiYgcHJvY2Vzc2VkQ3VzdG9tZXJHcm93dGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3B1bGFySXRlbXM6IFtdLFxuICAgICAgICBvcmRlclBhdHRlcm5zOiBbXSxcbiAgICAgICAgY3VzdG9tZXJHcm93dGg6IFtdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcHVsYXJJdGVtczogcHJvY2Vzc2VkUG9wdWxhckl0ZW1zLFxuICAgICAgb3JkZXJQYXR0ZXJuczogcHJvY2Vzc2VkT3JkZXJQYXR0ZXJucyxcbiAgICAgIGN1c3RvbWVyR3Jvd3RoOiBwcm9jZXNzZWRDdXN0b21lckdyb3d0aFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhbmFseXRpY3MgZGF0YTonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59ICJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJnZXRBbmFseXRpY3NEYXRhIiwic3VwYWJhc2UiLCJkYXRhIiwib3JkZXJzIiwiZXJyb3IiLCJvcmRlcnNFcnJvciIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImFzY2VuZGluZyIsImxpbWl0IiwiaXRlbVN0YXRzIiwicmVkdWNlIiwiYWNjIiwibWVudV9pdGVtIiwiaXRlbU5hbWUiLCJuYW1lIiwicHJpY2UiLCJxdWFudGl0eSIsImNvdW50IiwicmV2ZW51ZSIsInByb2Nlc3NlZFBvcHVsYXJJdGVtcyIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJvcmRlckNvdW50Iiwic29ydCIsImEiLCJiIiwic2xpY2UiLCJ0aGlydHlEYXlzQWdvIiwiRGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwicmVjZW50T3JkZXJzIiwicmVjZW50T3JkZXJzRXJyb3IiLCJndGUiLCJ0b0lTT1N0cmluZyIsImRhaWx5T3JkZXJzIiwiZGF0ZSIsImNyZWF0ZWRfYXQiLCJzcGxpdCIsInByb2Nlc3NlZE9yZGVyUGF0dGVybnMiLCJnZXRUaW1lIiwiY3VzdG9tZXJzIiwiY3VzdG9tZXJzRXJyb3IiLCJkYWlseUN1c3RvbWVycyIsImN1c3RvbWVyIiwibmV3IiwidG90YWxDdXN0b21lcnMiLCJwcm9jZXNzZWRDdXN0b21lckdyb3d0aCIsIm5ld0N1c3RvbWVycyIsImxlbmd0aCIsInBvcHVsYXJJdGVtcyIsIm9yZGVyUGF0dGVybnMiLCJjdXN0b21lckdyb3d0aCIsImNvbnNvbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/analytics.ts\n"));

/***/ })

});